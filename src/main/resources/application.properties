spring.application.name=development-hour-management

# Database Configuration
spring.datasource.url=jdbc:mysql://${DB_BE_KRONOS_BACKEND_BE_KRONOS_BACKEND_USER_01_DB_HOST}:${DB_BE_KRONOS_BACKEND_BE_KRONOS_BACKEND_USER_01_DB_PORT}/${DB_BE_KRONOS_BACKEND_BE_KRONOS_BACKEND_USER_01_DB_SCHEMA}
spring.datasource.username=${DB_BE_KRONOS_BACKEND_BE_KRONOS_BACKEND_USER_01_DB_USERNAME:devhour_user}
spring.datasource.password=${DB_BE_KRONOS_BACKEND_BE_KRONOS_BACKEND_USER_01_DB_PASSWORD:devhour_password}
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# HikariCP Configuration
spring.datasource.hikari.maximum-pool-size=${HIKARI_MAXIMUM_POOL_SIZE:10}
spring.datasource.hikari.minimum-idle=${HIKARI_MINIMUM_IDLE:5}
spring.datasource.hikari.connection-timeout=${HIKARI_CONNECTION_TIMEOUT:30000}
spring.datasource.hikari.idle-timeout=${HIKARI_IDLE_TIMEOUT:600000}
spring.datasource.hikari.max-lifetime=${HIKARI_MAX_LIFETIME:1800000}

# MyBatis Configuration
mybatis.configuration.map-underscore-to-camel-case=true
mybatis.type-aliases-package=com.devhour.domain.model
mybatis.type-handlers-package=com.devhour.infrastructure.typehandler
mybatis.configuration.default-fetch-size=100
mybatis.configuration.default-statement-timeout=30

# Flyway Configuration
spring.flyway.enabled=false
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true

# Enable Okta Security (Resource Server mode)
security.okta.enabled=true

# Allow bean definition overriding for custom JWT converter
spring.main.allow-bean-definition-overriding=true

# Spring Security OAuth2 Resource Server
# Configures the application to validate JWT tokens from Okta
# Using Okta's default custom Authorization Server
spring.security.oauth2.resourceserver.jwt.issuer-uri=${OAUTH2_ISSUER_URI}
spring.security.oauth2.resourceserver.jwt.jwk-set-uri=${OAUTH2_JWK_SET_URI}
spring.security.oauth2.resourceserver.jwt.client-id=${OAUTH2_CLIENT_ID}
spring.security.oauth2.resourceserver.jwt.audience=${OAUTH2_AUDIENCE}

# Okta Client Configuration
okta.client.token-expiry-tolerance=60

# AspectJ Logging Configuration
logging.level.com.devhour.infrastructure.aspect=INFO
# パフォーマンス監視の閾値（ミリ秒）
performance.slow-method-threshold=1000

# Logging pattern for console output
logging.pattern.console=%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

spring.devtools.restart.enabled=${SPRING_DEVTOOLS_RESTART_ENABLED:false}
spring.devtools.livereload.enabled=${SPRING_DEVTOOLS_LIVERELOAD_ENABLED:false}

# Kafka Configuration (disabled by default)
spring.kafka.enabled=${KAFKA_ENABLED:false}
spring.kafka.bootstrap-servers=${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
spring.kafka.consumer.group-id=${KAFKA_CONSUMER_GROUP_ID:work-hours-approval-group}
spring.kafka.consumer.auto-offset-reset=earliest
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=com.devhour.domain.event
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer
spring.kafka.producer.acks=${KAFKA_PRODUCER_ACKS:all}

# OpenAPI/Swagger Configuration
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.operations-sorter=method

# JIRA Integration Configuration
# Master switch for JIRA integration features
jira.integration.enabled=${JIRA_INTEGRATION_ENABLED:false}
jira.base-url=${JIRA_BASE_URL:https://your-jira-instance.atlassian.net}
jira.timeout.connection=30000
jira.timeout.read=60000
jira.retry.max-attempts=3
jira.retry.backoff-multiplier=2.0

jira.auth.token=${JIRA_API_TOKEN}

# JIRA Sync Scheduler Configuration
# Note: Scheduler is controlled by jira.integration.enabled
jira.sync.scheduler.cron=${JIRA_SYNC_SCHEDULE:0 0 * * * *}
jira.sync.scheduler.lock-at-most-for=${JIRA_SYNC_LOCK_AT_MOST:PT10M}
jira.sync.scheduler.lock-at-least-for=${JIRA_SYNC_LOCK_AT_LEAST:PT1M}

# JIRA Sync Batch Processing Configuration
jira.sync.batch-size=${JIRA_SYNC_BATCH_SIZE:50}
jira.sync.memory-efficient-processing=true
jira.sync.progress-logging.enabled=true
jira.sync.progress-logging.interval=10
jira.sync.streaming.chunk-size=${JIRA_SYNC_STREAMING_CHUNK_SIZE:100}
jira.sync.performance-monitoring.enabled=true

# Project Status Mapping Configuration
# Maps JIRA status strings to internal ProjectStatus enum values
project.status.mapping.in-progress=${JIRA_PROJECT_STATUS_MAPPING_INPROGRESS: ACTIVE,IN_PROGRESS,STARTED,ONGOING}
project.status.mapping.closed=${JIRA_PROJECT_STATUS_MAPPING_CLOSED:COMPLETED,DONE,FINISHED,RESOLVED,CLOSED}
project.status.mapping.draft=${JIRA_PROJECT_STATUS_MAPPING_DRAFT:PLANNING,NEW,OPEN,TO_DO,BACKLOG}
project.status.mapping.default-status=${JIRA_PROJECT_STATUS_MAPPING_DEFAULT:DRAFT}

# Disable Spring Boot HTTP client autoconfiguration
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.http.client.HttpClientAutoConfiguration,org.springframework.boot.autoconfigure.web.client.RestClientAutoConfiguration
